#       Tech Stack
[rem]:  ##########

## Paket
Paket is an alternative package management tool (alternative to NuGet)

### Files
| File | Location | Modified by | Source control ? | Role |
| - | - | - | - | - |
| paket.dependencies | Solution folder | user | yes | Specify all top level dependencies for the solution (with optional version numbers) |
| paket.references | Project folders | user | yes | Specify which projects use which dependency |
| paket.lock | Solution folder | paket | yes | Generated by Paket to fix all version numbers accross the solution |

#### paket.dependencies
```ps1
source https://api.nuget.org/v3/index.json
# source C:\Dev_Nuget\packages
# source "C:\Program Files (x86)\Microsoft SDKs\NuGetPackages\"

# optional
framework: net6.0

# optional
# Do not extract into the "packages" folder but use a globally shared directory
storage: none

# >= 0
nuget Newtonsoft.Json

# strict version
nuget Newtonsoft.Json = 13.0.2
nuget Newtonsoft.Json 13.0.2

nuget Example >= 1.2.3       # At least 1.2.3
nuget Example > 1.2.3        # Greater than 1.2.3
nuget Example <= 1.2.3       # Less than or equal to 1.2.3
nuget Example < 1.2.3        # Less than 1.2.3
nuget Example >= 1.2.3 < 1.5 # At least 1.2.3 but less than 1.5

# Pessimistic version constraint
# ==============================
nuget Example ~> 1.2.3

~> 0                        # 0 <= x < 1
~> 1.0                      # 1.0 <= x < 2.0
~> 1.2                      # 1.2 <= x < 2.0
~> 1.2.3                    # 1.2.3 <= x < 1.3
~> 1.2.3.4                  # 1.2.3.4 <= x < 1.2.4
~> 1.2.3-alpha001           # 1.2.3-alpha001 <= x < 1.3

~> 1.2 >= 1.2.3             # 1.2.3 <= x < 2.0

# Prereleases
# ===========
nuget Example >= 1.2.3 alpha  # At least 1.2.3 including alpha versions.
nuget Example >= 2 beta rc    # At least 2.0 including rc and beta versions.
nuget Example >= 3 rc         # At least 3.0 including rc versions.
nuget Example >= 3 prerelease # At least 3.0 including all prerelease versions.


# Transitive dependencies
# =======================
# you can also add transitive dependencies here
# if you want to fix their version

# might fail if 1.2.3 does not fit every other constraints
nuget Transitive = 1.2.3

# change conflicting constraints and pick 1.2.3 for everyone
nuget Transitive == 1.2.3
```

#### paket.references
```
Newtonsoft.Json
```

### Install Paket dotnet tool
```ps1
dotnet new tool-manifest
dotnet tool install paket
dotnet tool restore

# add paket-files/ to .gitignore
```

### Convert a solution from NuGet to Paket
```ps1
# creates:
#  - paket.dependencies
#  - paket.lock
#  - [Project folders]/paket.references
#
# creates (internal):
#  - .paket/Paket.Restore.targets
#  - paket-files/paket.restore.cached
#
# in every project files, replaces nuget references with
# <Import Project="..\.paket\Paket.Restore.targets" />

dotnet paket convert-from-nuget
```

### Initialize Paket in a solution
```ps1
# creates:
#   - paket.dependencies
#   - paket-files/

dotnet paket init

# create a paket.references file in every project folder

# compute and install dependencies
dotnet paket install
```

### Use Paket
```ps1
# add CliWrap to all projects
dotnet paket add CliWrap

# add CliWrap to a specific project
dotnet paket add --project xxx.csproj CliWrap

# remove CliWrap
dotnet paket remove CliWrap

# - compute dependency graph
# - download dependencies
# - update projects
dotnet paket install

# - download computed dependency graph
dotnet paket restore

# simplify declared dependencies by removing transitive dependencies
dotnet paket simplify

# check if new versions of dependencies are available
dotnet paket outdated

# update dependencies to their latest version
# within the constraints specified
dotnet paket update
```

&nbsp;


## Fable

### Create a Fable project from scratch
```ps1
# Create project
# ==============
dotnet new sln -o FromScratch
cd FromScratch
dotnet new classlib -o MyClient -lang "F#" -f netstandard2.0
dotnet sln add MyClient\MyClient.fsproj

# Use Paket
# =========
dotnet new tool-manifest
dotnet tool install paket
dotnet tool restore
dotnet paket convert-from-nuget --no-install
```

#### edit .gitignore
```
bin/
obj/
paket-files/
```

#### edit ./paket.dependencies
```
source https://api.nuget.org/v3/index.json
framework: netstandard2.0

nuget FSharp.Core
```

```ps1
# Install Fable
# =============
dotnet tool install fable --prerelease
dotnet paket add Fable.Core --version ">= 4 theta"
dotnet paket add Fable.Browser.Dom
dotnet paket install
```

#### Create ./package.json
```json
{
    "type": "module",
    "license": "MIT"
}
```

```ps1
yarn add -D vite

# creates:
#  - node_modules
#  - yarn.lock
yarn
```

#### Create ./vite.config.js
```js
import { defineConfig } from 'vite'

export default defineConfig({
    plugins: [
    ],
    root: "./MyClient",
    server: {
        port: 8080,
        proxy: {
            '/api': 'http://localhost:5000',
        }
    },
    build: {
        outDir:"./"
    }
})
```

#### Create ./MyClient/index.html
```html
<!doctype html>
<html>
<head>
  <title>FromScratch</title>
  <meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script src="output/App.js" type="module"></script>
</body>
</html>
```

```ps1
# rename ./MyClient/Library.fs to ./MyClient/App.fs
# (and change the name in the .fsproj file)
# Paste the content below

# Run
# ===
dotnet fable MyClient\MyClient.fsproj -o output
yarn run vite
```

#### Content of ./MyClient/App.fs
```f#
module App

open Fable.Core.JsInterop

let window = Browser.Dom.window

// Get our canvas context 
// As we'll see later, myCanvas is mutable hence the use of the mutable keyword
// the unbox keyword allows to make an unsafe cast. Here we assume that getElementById will return an HTMLCanvasElement 
let mutable myCanvas : Browser.Types.HTMLCanvasElement = unbox window.document.getElementById "myCanvas"  // myCanvas is defined in public/index.html

// Get the context
let ctx = myCanvas.getContext_2d()

// All these are immutables values
let w = myCanvas.width
let h = myCanvas.height
let steps = 20
let squareSize = 20

// gridWidth needs a float wo we cast tour int operation to a float using the float keyword
let gridWidth = float (steps * squareSize) 

// resize our canvas to the size of our grid
// the arrow <- indicates we're mutating a value. It's a special operator in F#.
myCanvas.width <- gridWidth
myCanvas.height <- gridWidth

// print the grid size to our debugger console
printfn "%i" steps

// prepare our canvas operations
[0..steps] // this is a list
  |> Seq.iter( fun x -> // we iter through the list using an anonymous function
      let v = float ((x) * squareSize) 
      ctx.moveTo(v, 0.)
      ctx.lineTo(v, gridWidth)
      ctx.moveTo(0., v)
      ctx.lineTo(gridWidth, v)
    ) 
ctx.strokeStyle <- !^"#ddd" // color

// draw our grid
ctx.stroke() 

// write Fable
ctx.textAlign <- "center"
ctx.fillText("Fable on Canvas", gridWidth * 0.5, gridWidth * 0.5)

printfn "done!"
```